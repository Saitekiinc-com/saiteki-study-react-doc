# AIネイティブ・エンジニアリング指針

AI（LLM）の進化は、ソフトウェアエンジニアリングのあり方を根本から変えようとしています。
本ドキュメントでは、エンジニアに求められる役割がどう変化しているのか（As-Is / To-Be）、そして今後どのように学習・開発を進めるべきかについて解説します。

## 1. What is AI: 本研修におけるAIの定義

本研修において、AI（LLM）を **「超絶技巧を持つオーケストラ（演奏家たち）」** と定義します。
エンジニアであるあなたの役割は、彼らを率いる **「指揮者」** です。

*   **AIの特性**:
    *   **技術力**: どんな難解な譜面（コードやボイラープレート）も、一瞬で正確に演奏できます。
    *   **受動性**: しかし、指揮者がテンポや解釈（仕様や設計方針）を示さない限り、勝手に演奏を始めることはできません。あるいは、指示が曖昧だと不協和音（バグやハルシネーション）を奏でます。

エンジニアの仕事は、自ら楽器を弾く（コーディング）ことから、**「オーケストラ（AI）を指揮し、最高の音楽（価値）を創り出すこと」** へと変化しました。

## 2. The Impact: 価値の移動

なぜ、AIの登場でエンジニアの役割が変わるのでしょうか？
それは、**「How（実装）」から「What（要件）・Why（設計）」へ**、価値の源泉が移動したからです。

### 「How（実装）」のコモディティ化
かつては、複雑な要件を自力でコードに落とし込む「実装能力」そのものが、エンジニアとしての主要な価値とされていました。
しかし、現在では状況が一変しています。AIは、既知のデザインパターンやアルゴリズムであれば、人間よりも遥かに高速かつ正確にコードを生成することができます。
「ReactでTodoアプリを構築する」「SQLで複雑なデータ抽出を行う」といった、<strong>「How（どのように実装するか）」という作業自体の市場価値は、急速にコモディティ化し、限りなくゼロに近づいています。</strong>

### 「What（要件）」と「Why（設計）」への価値移動
一方で、AIは「創造的な意思決定」や「責任ある判断」を苦手としています。
ビジネスの本質的な課題を深く理解し、それを解決するために<strong>最適なシステム要件を定義すること（What）</strong>、そして数ある技術の中から<strong>なぜそのアーキテクチャを選定したのかという設計意図を決定すること（Why）</strong>こそが、人間（指揮者）だけが担える重要な役割です。
エンジニアリングの価値の源泉は、もはやAIが得意とする「中流工程（実装）」にはありません。人間ならではの創造性が発揮される<strong>「上流工程（要件定義・設計）」と、品質を最終保証する「下流工程（検証・QA）」へと完全に移動しました。</strong>

## 3. As-Is / To-Be: エンジニア像の変化

この価値移動に伴い、目指すべきエンジニア像は「ソロ演奏者」から「指揮者」へとシフトします。

| 観点 | 🕰️ As-Is (Before AI) | 🚀 To-Be (After AI) |
| :--- | :--- | :--- |
| **役割** | **作業者** | **設計者** |
| **業務の重心** | **単純作業** | **高度な設計** |
| **価値の源泉** | **実装力（どう作るか）** | **設計・判断力（何を・なぜ作るか）** |
| **必要な知識** | **特定の言語・フレームワークの深い知識** | **幅広い技術スタックの理解と、原理原則** |

### 3.1 変化のポイント: 「手を動かす」から「頭を動かす」へ

この変化は、技術的な制約から解放され、より本質的な価値創造へと向かうプロセスとして理解できます。

1.  **Step 1: 実装負荷における「量」の壁の突破**
    *   これまでは、アイデアを形にするために膨大な時間をかけてコードを書く必要がありました（コーディングが最大のボトルネック）。
    *   そのため、文法を正確に暗記し、物理的に速くコードを記述できるスキルが高い評価を得ていました。

2.  **Step 2: AIによる「速度」の獲得と新たな課題**
    *   AIの活用により、私たちは実装作業を一瞬で完了させる力を手に入れました。しかし、これは諸刃の剣でもあります。
    *   AIは「指示されたこと」しか実行できません。もし私たちの指示が曖昧であったり間違っていれば、AIは「誤ったプログラム」を人間には不可能な速度で大量生産してしまいます。

3.  **Step 3: 「言語化能力」と「審美眼」への進化**
    *   したがって、これからのエンジニアに最も求められる資質は、以下の2点に集約されます。
        *   **言語化能力（Prompting）**: 自身の意図を論理的かつ明確に言語化し、AIというパートナーに正しい指示を与える力。
        *   **審美眼（Verification）**: AIが生成した成果物が、ビジネス要件や非機能要件（セキュリティ・パフォーマンス）を真に満たしているかを厳しく見極める力。

### 3.2 進化へのアプローチ: 「自分の担当パート」から「オーケストラ全体」へ

優れた指揮者は、自分が得意な特定の楽器だけでなく、オーケストラを構成するすべての楽器の特性や役割を深く理解しています。「自分の担当パート」しか知らない状態では、全体を統率し、美しい調和（ハーモニー）を生み出すことはできないからです。

この原則は、エンジニアリングの世界でも全く同じです。
システム全体を俯瞰し、最適な設計・判断を行うためには、自身の専門分野（フロントエンドやバックエンドなど）に詳しいだけでは不十分です。システムの全体構造や、隣接する技術領域についても深く理解する必要があります。
AIの活用によって、得意領域の実装にかかる時間は劇的に短縮されます。そこで浮いた時間を活用し、**「意識的に隣接領域へ学習範囲を広げ、技術的な守備範囲を拡大すること」**が、これからのエンジニアに求められる成長戦略です。

## 4. Evolution Path: ロール別の進化プロセス

AIを活用することで、エンジニアは「演奏者」から「指揮者」へと進化します。
しかし、これは「演奏（実装）」を捨てるという意味ではありません。名指揮者の多くが元々は優れたソリストであるように、**「特定の専門分野（バックグラウンド）で培った深い知見と経験」**こそが、AIの成果物を正しく評価し、全体を指揮するための最も重要な武器になります。

あなたの「得意な楽器」を基盤としつつ、どのように領域を広げ、オーケストラ全体の指揮を執れるようになるか、そのロードマップを以下に示します。

#### 全ロール共通の進化プロセス
各専門分野（ロール）ごとの詳細は後述しますが、全員が目指すべき「指揮者」への進化プロセスには共通した型があります。

1.  **Phase 1: AIによる加速**
    *   AIを徹底的に活用し、自分の得意な「担当楽器（専門領域）」の実装作業を高速化・効率化する。
2.  **Phase 2: 領域の拡張**
    *   高速化によって生まれた余力を使い、意識的に「隣接する他領域」へ知識とスキルを広げる。
3.  **Phase 3: 全体設計**
    *   自身の専門性を軸にしながら、システム全体を俯瞰し、全体最適の視点で設計・判断を行う。

> [!NOTE]
> 以下の各ロールにおける「挑む領域 (Target)」や「推奨カリキュラム」の実例は、現時点での案（Draft）です。具体的な目標設定や評価基準については、今後のチーム内での議論・相談を通じて決定していきます。

### ⚛️ For Frontend Engineers (フロントエンド出身)
**「与えられた画面を実装する人」から「理想の顧客体験を実現するために、システム全体を動かす人」へ**

*   **責任の起点**: ユーザーの五感・感情
*   **ゴール**: 「心地よい・ストレスがない」
*   **進化のステップ**:
    1.  **Phase 1**: AIの活用により、UI実装の速度と品質を極限まで高めます。
    2.  **Phase 2**: 「APIが遅いからUXが悪い」という他責思考を脱却し、最高のUXを実現するためならAPI設計やDBスキーマまで踏み込んで改善提案を行うスタンスへと変化します。
    3.  **Phase 3**: 最終的に、ユーザー体験を阻害するあらゆる要因（インフラ、ネットワーク含む）を特定し、全体最適の視点で解決策を指揮できるアーキテクトとなります。

| 挑む領域 (Target) | 目的 (Why) | AI任せの時の盲点 (Blind Spot) | 推奨カリキュラム (Action) |
| :--- | :--- | :--- | :--- |
| **Backend: API Design** | **「待ち時間ゼロのUX改善」**<br>「APIが遅い」と依頼して待つのではなく、自らN+1を特定・修正し、**UXへの執念**を実装に反映させる。UIに最適化されたBFFを設計する。 | **「パフォーマンスの無視」**<br>必要なデータだけを効率よく取得する視点が抜け、無駄な通信が発生する。 | **[Lv.2 Application (Backend)](/training/curriculum/level2_application)**<br>API設計とBFF。 |
| **Backend: DB Schema** | **「データの整合性とUXの両立」**<br>「DB的には正しいが画面表示が遅い」を防ぐ。必要な場面では意図的な非正規化を行うなど、UX起点のスキーマ設計を行う。 | **「正規化の欠如」**<br>画面の都合だけでテーブルを作り、データの重複や不整合を招く。 | **[Lv.2 Application (Backend)](/training/curriculum/level2_application)**<br>DB設計と正規化。 |
| **Infra: Delivery (CDN)** | **「最速のレンダリング」**<br>静的アセットのキャッシュ戦略を制御する。 | **「キャッシュ事故」**<br>古いコンテンツが残り続ける、またはキャッシュが効いていない。 | **[AWS / Infra](/training/aws/index)**<br>CDNとキャッシュ戦略。 |
| **Infra: Security** | **「安全な通信」**<br>CORSやWAFの設定。 | **「設定ミスによる脆弱性」**<br>開発環境の設定（全許可）を本番に持ち込む。 | **[AWS / Infra](/training/aws/index)**<br>セキュリティ設定。 |
| **QA** | **「非機能要件の担保」**<br>見た目だけでなく、エッジケースや異常系でも壊れない堅牢なUIを作る。 | **「Happy Pathのみのテスト」**<br>異常系の考慮漏れ。 | **[Lv.3 Quality](/training/curriculum/level3_quality)**<br>E2Eテスト。 |

---

### 🔙 For Backend Engineers (サーバーサイド出身)
**「要件通りの機能を実装する人」から「サービス全体を俯瞰し、ビジネス価値を安定して届け続ける仕組みを作る人」へ**

*   **責任の起点**: ビジネス価値・機能
*   **ゴール**: 「役に立つ・信頼できる」
*   **進化のステップ**:
    1.  **Phase 1**: AIを活用し、CRUD処理やAPI実装などの定型業務を効率化し、実装スピードを最大化します。
    2.  **Phase 2**: 「機能は作ったが、UIが使いにくく価値が届かない」という事態を防ぐため、フロントエンドの状態管理やコンポーネント設計を深く理解し、使い手にとって最適なデータ構造を提案するスタンスへと変化します。
    3.  **Phase 3**: 最終的に、UI（入り口）からインフラ（土台）まで、ユーザーに価値が届くすべての一連の経路を設計・保証できるサービスアーキテクトとなります。

| 挑む領域 (Target) | 目的 (Why) | AI任せの時の盲点 (Blind Spot) | 推奨カリキュラム (Action) |
| :--- | :--- | :--- | :--- |
| **Frontend: Components** | **「再利用性と保守性」**<br>変更に強いUIコンポーネントを設計する。 | **「コピペ実装」**<br>似たようなコードが散乱し、デザイン変更に追従できない。 | **[Lv.1 Foundation (UI)](/training/curriculum/level1_foundation)**<br>コンポーネント設計。 |
| **Frontend: State** | **「複雑な状態管理」**<br>非同期データとクライアント状態（ローディング、エラー）を適切に扱う。 | **「競合状態 (Race Condition)」**<br>連打時の挙動や、古いデータの上書きを考慮しない。 | **[Lv.2 Application](/training/curriculum/level2_application)**<br>状態管理と非同期処理。 |
| **Infra: Compute** | **「モダンな実行環境」**<br>Serverlessやコンテナを活用し、運用コストを下げる。 | **「スケーラビリティの欠如」**<br>ステートフルな設計にしてしまい、スケールアウトできない。 | **[AWS / Infra](/training/aws/index)**<br>コンテナとサーバーレス。 |
| **Infra: Observability** | **「運用監視」**<br>ログやトレースを仕込み、障害時に即座に原因を特定する。 | **「デバッグ情報の不足」**<br>エラーログが出ない、あるいはノイズが多すぎる。 | **[AWS / Infra](/training/aws/index)**<br>ログ設計と監視。 |
| **QA** | **「ロジックの完全性」**<br>複雑なビジネスルールやデータ整合性が、あらゆるエッジケースで守られることを保証する。 | **「境界値と競合状態の無視」**<br>AIは単純なUnit Testは書くが、並列処理時の競合や、複雑な状態遷移のテストケースを見落とす。 | **[Lv.3 Quality](/training/curriculum/level3_quality)**<br>テスト戦略と結合テスト。 |

---

### 🧪 For QA Engineers (品質保証出身)
**「完成品のテストを行う人」から「上流工程から品質を作り込み、手戻りのない開発プロセスを設計する人」へ**

*   **責任の起点**: ユーザーの信頼・安心
*   **ゴール**: 「当たり前に動く・壊れない」
*   **進化のステップ**:
    1.  **Phase 1**: AIを活用し、テストケースの網羅的な生成や自動テストコードの実装を任せ、検証作業の効率を最大化します。
    2.  **Phase 2**: 「完成品を後からテストする」という受動的な役割から脱却し、要件定義や設計段階から参画して品質基準を組み込む（シフトレフト）ことで、手戻りを未然に防ぐスタンスへと変化します。
    3.  **Phase 3**: 最終的に、開発プロセス全体を通じて品質が自動的に担保される仕組みを構築し、リリースの高速化と高品質を両立させるアーキテクトとなります。

| 挑む領域 (Target) | 目的 (Why) | AI任せの時の盲点 (Blind Spot) | 推奨カリキュラム (Action) |
| :--- | :--- | :--- | :--- |
| **Unit/Integration**<br>(Dev) | **「テスト戦略の策定」**<br>開発者が書くUTのレビューや、結合テストの自動化をリードする。 | **「網羅性の欠如」**<br>AIは正常系テストは得意だが、異常系や境界値テストを見落とす。 | **[Lv.3 Quality](/training/curriculum/level3_quality)**<br>テスト戦略と自動化。 |
| **Infra** | **「インフラのテスト (IaC Testing)」**<br>Terraformのセキュリティチェックや、負荷試験のシナリオ作成。 | **「非機能要件の無視」**<br>機能は動くが、スパイクアクセスで落ちる構成になっていないか？ | **[AWS / Infra](/training/aws/index)**<br>負荷試験とセキュリティ。 |
| **CI/CD** | **「品質ゲートの自動化」**<br>パイプラインに自動テストやセキュリティスキャンを組み込み、バグを早期発見する。 | **「パイプラインの形骸化」**<br>落ちても無視されるテストや、遅すぎるビルド。 | **[Lv.4 Architecture](/training/curriculum/level4_architecture)**<br>CI/CDとDevOps。 |

---

### ☁️ For Infrastructure / SRE Engineers
**「設定ファイルを書く人」から「サービスの信頼性と、チーム全体の開発スピードを最大化する土台を作る人」へ**

*   **責任の起点**: システムの信頼性・開発生産性
*   **ゴール**: 「止まらない・デプロイが速い」
*   **進化のステップ**:
    1.  **Phase 1**: AIにIaCコード（Terraform/K8s）を書かせ、構築作業を自動化することで、作業時間を極小化します。
    2.  **Phase 2**: インフラの上で動くアプリケーションの内部構造まで理解し、CPU/メモリだけでなくコードレベルのボトルネックまで特定・改善できるスタンスへと変化します。
    3.  **Phase 3**: 最終的に、開発者がインフラを意識せずとも、安全・高速に機能リリースできる「プラットフォーム」そのものを提供するアーキテクトとなります。

| 挑む領域 (Target) | 目的 (Why) | AI任せの時の盲点 (Blind Spot) | 推奨カリキュラム (Action) |
| :--- | :--- | :--- | :--- |
| **Backend: App Logic** | **「アプリ起因の障害特定」**<br>CPU/メモリだけでなく、N+1問題やメモリリークなど、コードレベルのボトルネックを特定する。 | **「リソースの無駄遣い」**<br>コードが悪いのに、AIに言われるがままインスタンスサイズを上げて解決しようとする。 | **[Lv.2 Application (Backend)](/training/curriculum/level2_application)**<br>DB設計とパフォーマンス。 |
| **Frontend: Edge/CDN** | **「ユーザー体験の最適化」**<br>CDNのエッジロジックやキャッシュ戦略を駆使して、LCP (Largest Contentful Paint) を改善する。 | **「キャッシュ事故」**<br>動的コンテンツをキャッシュしてしまったり、デプロイ後に古いファイルが残る。 | **[Lv.1 Foundation (Web)](/training/curriculum/level1_foundation)**<br>HTTPとキャッシュ。 |
| **QA: Chaos Engineering** | **「回復性のテスト」**<br>障害を意図的に起こし、システムが自律的に回復するかを検証する。 | **「正常系の過信」**<br>AIは「落ちない前提」の構成案を出しがち。 | **[Lv.3 Quality](/training/curriculum/level3_quality)**<br>非機能要件テスト。 |

---

### 📝 For Planners / PMs (非エンジニア)
**「要件を文字で伝える人」から「ビジネスと技術のトレードオフを見極め、最短で市場価値を創出する人」へ**

*   **責任の起点**: 事業のスピード・コスト
*   **ゴール**: 「市場価値の創出」
*   **進化のステップ**:
    1.  **Phase 1**: AIでプロトタイプを短時間で作成し、紙の仕様書ではなく「実際に動くもの」を使って要件を詰めるスタイルへ移行します。
    2.  **Phase 2**: エンジニア任せにしていた技術的な裏側（アーキテクチャ・コスト）を理解し、実現可能性とコストのバランスをエンジニアと対等に議論できる状態になります。
    3.  **Phase 3**: 最終的に、ビジネスインパクトと技術的負債のトレードオフを正しく判断し、プロダクトの成功確率（ROI）を最大化する意思決定者となります。

| 挑む領域 (Target) | 目的 (Why) | AI任せの時の盲点 (Blind Spot) | 推奨カリキュラム (Action) |
| :--- | :--- | :--- | :--- |
| **Prototyping** | **「高速な仮説検証」**<br>エンジニアに依頼する前に、AIでモックアップを作り、仕様の矛盾やUXの課題を洗い出す。 | **「捨てられないコード」**<br>プロトタイプをそのまま本番採用しようとして、後の保守コストを増大させる（プロトタイプは捨てるもの）。 | **[Lv.1 Workshop](/training/curriculum/level1_workshop)**<br>AIを使ったアプリ生成体験。 |
| **Architecture** | **「投資判断の適正化」**<br>「技術的負債」や「セキュリティリスク」を理解し、機能追加とリファクタリングのバランスを判断する。 | **「見えないコストの増大」**<br>「動いているからOK」と判断し、裏側でセキュリティホールやスパゲッティコードが量産されていることに気づけない。 | **[Lv.4 Architecture](/training/curriculum/level4_architecture)**<br>アーキテクチャの基礎概念。 |


## 5. Future: 今後の展望

### フルスタック化の加速
AIの支援により、未知の言語やフレームワークを扱う障壁が劇的に下がりました。
フロントエンドエンジニアがバックエンドやインフラ（AWS/Terraform）を触る、あるいはその逆が当たり前になります。
**「専門外だからできない」という言い訳は通用しなくなり、サービス全体を俯瞰できる（指揮できる）フルスタックな能力**が求められます。

**この進化がもたらす価値:**

*   **エンジニアにとって (Career Value)**:
    *   **市場価値の最大化**: 「特定技術しかできない人」はAIに代替されやすいですが、「課題解決のために何でも使う人」は代替不可能です。
    *   **裁量の拡大**: 自分で全てを作れるため、作りたいプロダクトを誰の許可も待たずに形にできます。
*   **組織にとって (Business Value)**:
    *   **フロー効率の劇的向上**: 「待ち時間」や「コミュニケーションコスト」が消滅し、少人数で大規模な開発が可能になります。
    *   **イノベーションの加速**: エンジニア一人ひとりがビジネス視点と実装力の両方を持つことで、現場からボトムアップで改善案が生まれます。

## 6. Action: 今やるべきこと

指揮者がタクトを振ってオーケストラに指示を出すように、エンジニアはAIに対して明確な指示（プロンプト）を出し、その結果を厳しくチェック（検証）する必要があります。

### ① 基礎知識と原理原則 (Foundation / Score Reading)
AIの **「嘘」** や **「限界」** を技術的に解決するための知識です（楽譜を正しく読む力）。

*   **ハルシネーション（嘘）への対策**:
    *   **課題**: AIは知らない情報を、さも知っているかのように捏造することがあります。
    *   **対策**: **「学習データに頼るな」** と判断し、**Function Calling（検索ツールやAPI実行）**を使って、外部の正しい情報をAIに与える設計を組み込みます。
*   **ベストプラクティスの理解**:
    *   **課題**: AIは **「古い書き方」** や **「セキュリティの低いコード」** も出力します。
    *   **対策**: エンジニア自身が **「現在の推奨パターン」** を知っておかないと、レガシーコードの量産を許してしまいます。

### ② 言語化能力 (Prompt Engineering / Directions)
AIを制御するための **「仕様を伝える力」** です（演奏指示を出す力）。

*   **要件定義の解像度**:
    *   **悪い例**: 「いい感じのモーダルを作って」
    *   **良い例**: 「Headless UIのDialogコンポーネントを使い、ESCキーで閉じる挙動と、背景スクロールのロックを実装してください」
    *   **対策**: 曖昧さを排除し、**「使用するライブラリ」** **「制約条件」** **「入力と出力」** を具体的に言語化するトレーニングを行います。
*   **コンテキストの注入**:
    *   **対策**: DBスキーマや既存のコード規約をプロンプトに含めることで、AIの回答精度を劇的に向上させます。

### ③ 多角的な検証能力 (Verification / Critiquing)
**「動くコード」** と **「プロダクト品質」** のギャップを埋める力です（リハーサルで音を磨く力）。

*   **非機能要件のチェック**:
    *   **課題**: AIは **「N+1問題」** や **「メモリリーク」** を考慮せず、単純に動くコードを書く傾向があります。
    *   **対策**: コードレビュー時に、**「機能要件（動くか）」** ではなく **「非機能要件（速いか・安全か）」** に焦点を当ててチェックします。
*   **エッジケースの検証**:
    *   **対策**: AIに「このコードの境界値テストケースを10個挙げて」と指示し、人間が思いつかないパターンのバグを炙り出させます。

---
AIの登場により、エンジニアリングの定義は大きく拡張されました。
コードを書くという作業（How）から解放された私たちは、より本質的な「課題解決（What）」と「価値創造（Why）」に全力を注ぐことができます。

**「AIに使われるな、AIを使いこなせ。」**

この言葉の本質は、単なるツールの操作スキルではありません。
AIという最高のオーケストラを指揮し、ビジネスにインパクトを与える「新しい時代のエンジニアリング」を、今日から共に始めていきましょう。
