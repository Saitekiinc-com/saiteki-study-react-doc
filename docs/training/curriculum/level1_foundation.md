# Lv.1 基礎: Webアプリケーションの仕組みと原理原則

Lv.1のゴールは、<strong>「特定の技術（How）ではなく、システム全体を貫く設計思想（Why/Philosophy）を理解すること」</strong>です。
ReactやAWSといった技術は時代とともに変わりますが、その根底にある「原理原則」は変わりません。フルスタックエンジニアとして、あらゆる技術選定の判断基準となるメンタルモデルを構築します。

## 1. Web標準とHTTP (The Infrastructure)
なぜWebはこれほどまでにスケールし、世界中のシステムを繋ぐことができたのか？その設計思想を学びます。

### 学習項目
*   **Statelessness (ステートレス)**:
    *   「サーバーはクライアントの状態を覚えない」という制約。
    *   なぜこれがスケーラビリティ（サーバーを何台でも増やせること）に直結するのか。
*   **Resource Orientation (リソース指向)**:
    *   「操作（動詞）」ではなく「リソース（名詞）」でシステムを捉える思考法。
    *   URLは「場所」ではなく「モノ」を指すべきである理由。
*   **Idempotency (冪等性)**:
    *   「同じリクエストを何度送っても結果が変わらない」という性質。
    *   ネットワークが不安定な環境で、安全にリトライ処理を行うための必須概念。

### チェックリスト
- [ ] 「ステートレスな設計」が、サーバーの負荷分散にどう役立つか説明できる。
- [ ] 冪等性が担保されていないAPIでリトライを行った場合のリスク（二重決済など）を説明できる。

## 2. 非同期と型システム (The Language)
JavaScript/TypeScriptという言語を通じて、現代のプログラミングに必須の「並行処理」と「契約」の概念を学びます。

### 学習項目
*   **Event Loop & Non-blocking (非同期の哲学)**:
    *   たった1つのスレッドで、数千の同時リクエストを捌く仕組み。
    *   「待ち時間（I/O）」を有効活用し、CPUを止めないという思想。
*   **Type System as a Contract (契約としての型)**:
    *   型は単なるエラーチェックではない。コンポーネント間の「契約書」である。
    *   「Any型」を使うことが、なぜ「契約違反（信頼の放棄）」になるのか。

### チェックリスト
- [ ] 「ブロッキング処理」がなぜWebサーバーにとって致命的なのか説明できる。
- [ ] 型定義を見るだけで、その関数の「責務」と「使い方」を理解できるコードを書ける。

## 3. フロントエンドのメンタルモデル (The UI)
UIライブラリの流行り廃りを超えて、GUIアプリケーション構築の普遍的な原則を学びます。

### 学習項目
*   **Declarative vs Imperative (宣言的 vs 命令的)**:
    *   「どう更新するか（手順）」ではなく「あるべき状態は何か（結果）」を定義する。
    *   手順の複雑さから解放され、バグを減らすためのパラダイムシフト。
*   **Single Source of Truth (信頼できる唯一の情報源)**:
    *   「データは一箇所にしか存在させない」という鉄則。
    *   状態のコピーを持った瞬間に、同期ズレというバグが生まれる理由。

### チェックリスト
- [ ] 「命令的」なコードと「宣言的」なコードの違いを、具体的な例（DOM操作など）で説明できる。
- [ ] 画面上のデータと、裏側のデータが食い違うバグの原因を「Single Source of Truth」の観点で特定できる。

## 4. コンポーネント設計 (The Architecture)
UIをメンテナンス可能な部品に分割するための設計論です。
Atomic Designなどの特定のメソドロジーに従うかどうかに関わらず、以下の「設計の思想」を押さえておくことが重要です。

### 学習項目
*   **関心の分離 (Separation of Concerns)**:
    *   **Presentational Component**: 「どう見えるか」だけを担当（Propsを受け取って描画）。
    *   **Container Component**: 「どう動くか」を担当（データを取得してPropsで渡す）。
    *   これらを分けることで、デザイン変更の影響をロジックに波及させないようにします。
*   **単一責任の原則 (Single Responsibility Principle)**:
    *   1つのコンポーネントは「1つのこと」だけをする。
    *   「ユーザー一覧を表示し、かつ、ユーザー登録もする」ような巨大なコンポーネントは分割する。
*   **依存の方向性**:
    *   特定のページでしか使えないコンポーネント（具体的）と、どこでも使えるボタン（抽象的）を区別する。
    *   抽象的なコンポーネントが、具体的なコンポーネントに依存しないようにする。

### チェックリスト
- [ ] ロジックを含むコンポーネントと、見た目だけのコンポーネントを分離して実装できる。
- [ ] 「このコンポーネントの役割は何か？」と聞かれたときに、一言で答えられる。

## 5. バックエンドとデータベース (The Data)
データを守り、正しく届けるためのトレードオフと契約について学びます。

### 学習項目
*   **ACID vs CAP Theorem (整合性と可用性のトレードオフ)**:
    *   「絶対にデータを失わない（整合性）」ことと「いつでも使える（可用性）」ことは、分散システムでは両立しない場合がある。
    *   銀行システムとSNSの「いいね」で、選ぶべきDBが異なる理由。
*   **API as a Contract (契約としてのAPI)**:
    *   APIは、バックエンドがフロントエンドに対して提供する「サービス保証」。
    *   一度公開したAPIを変更することが、なぜ「契約違反（Breaking Change）」として扱われるのか。

### チェックリスト
- [ ] 自分の作ろうとしているサービスが、整合性重視（ACID）か可用性重視（CAPのAP）か判断できる。
- [ ] APIのレスポンス構造を変更する際、クライアントにどのような影響が出るか予測できる。

## 推奨学習リソース
*   **[Webを支える技術](https://gihyo.jp/book/2010/978-4-7741-4204-3)**: Webのアーキテクチャスタイル（REST）を学ぶ名著。
*   **[プリンシプル オブ プログラミング](https://www.amazon.co.jp/dp/B01C2G6W54)**: 設計原理原則のカタログ。
